{
  "hash": "99921433fa848c0067955daf6f29fdbd",
  "result": {
    "markdown": "---\nexecute: \n  eval: false\n  echo: true\n  warning: false\n---\n\n\n# Creating a directory with data for the Shiny app\n\nHere, we will describe the code to create the files that will be required to\nrun the Shiny app. These files will be stored in a directory named `app_data`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123) # for reproducibility\n\n# Load required packages\nlibrary(here)\nlibrary(SummarizedExperiment)\nlibrary(arrow)\nlibrary(tidyverse)\nlibrary(rvest)\n```\n:::\n\n\n## *.parquet* files in `parquet_dir`\n\nGene-level transcript abundances in TPM and bias-corrected counts will be\nstored in a partitioned *.parquet* directory, so that expression data can be \naccessed in the app back-end with Apache Arrow via the \n`BiocStyle::CRANpkg(\"arrow\")` package.\n\nThis directory contains partitioned *.parquet* files with a gene expression \ndata frame in long format with the following variables:\n\n1. `Gene`: character, gene ID.\n2. `Sample`: character, sample name.\n3. `TPM`: numeric, gene-level transcript abundances in TPM.\n4. `Count`: numeric, gene-level transcript abundances in bias-corrected counts.\n5. `BioProject`: factor, BioProject IDs.\n6. `Part`: character, plant part.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load SummarizedExperiment object\nload(here(\"products\", \"result_files\", \"se_atlas_gene.rda\"))\n\n# Get expression data in long format\n## TPM\nexp_tpm <- assay(se_atlas_gene, \"gene_TPM\") |>\n    reshape2::melt() |>\n    mutate(\n        Gene = as.character(Var1),\n        Sample = as.character(Var2),\n        TPM = as.numeric(value)\n    ) |>\n    dplyr::select(Gene, Sample, TPM)\n\nhist(log_sorted_tpm)\n\n## Counts\nexp_counts <- assay(se_atlas_gene, \"gene_counts\") |>\n    reshape2::melt() |>\n    mutate(\n        Gene = as.character(Var1),\n        Sample = as.character(Var2),\n        Count = as.numeric(value)\n    ) |>\n    dplyr::select(Gene, Sample, Count)\n    \nnames(exp_counts) <- c(\"Gene\", \"Sample\", \"Count\")\n\n## Combine data frames\nidentical(exp_counts$Sample, exp_tpm$Sample)\nidentical(exp_counts$Gene, exp_tpm$Gene)\nexp_final <- cbind(exp_tpm, exp_counts[, \"Count\", drop = FALSE])\n\n# Export data with BioProject and Part info\nsample_metadata <- colData(se_atlas_gene) |>\n    as.data.frame() |>\n    tibble::rownames_to_column(\"BioSample\")\n\nsample_and_additional_info <- data.frame(\n    Sample = sample_metadata$BioSample,\n    BioProject = sample_metadata$BioProject,\n    Part = sample_metadata$Part\n)\n\nexp_final2 <- left_join(\n    exp_final, \n    sample_and_additional_info\n) |>\n    mutate(\n        BioProject = as.factor(BioProject),\n        Sample = as.factor(Sample),\n        BioProject = as.factor(BioProject),\n        Part = as.factor(Part)\n    )\n\nparquet_dir_partitioned <- here(\"app_data\", \"parquet_dir\")\nfs::dir_create(parquet_dir_partitioned)\n\narrow::write_dataset(\n    exp_final2, \n    path = parquet_dir_partitioned,\n    format = \"parquet\",\n    partitioning = c(\"BioProject\", \"Part\")\n)\n```\n:::\n\n\n## `expression_by_body_part/` directory\n\nThis directory contains static `.tsv` files with gene expression information\nby body part, and it is used by the \"Download by body part\" tab to avoid\nhaving to load large volumes of data in memory, which is problematic when there\nare too many users.\n\nFirst, let's export gene-level abundances.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(here(\"products\", \"result_files\", \"se_atlas_gene.rda\"))\n\n# Get a list of character vectors with samples per body part\nsamples_per_tissue <- colData(se_atlas_gene) |>\n    as.data.frame() |>\n    tibble::rownames_to_column(\"BioSample\")\n\nsamples_per_tissue <- split(\n    samples_per_tissue$BioSample, samples_per_tissue$Part\n)\n\n# Get expression data frames in TPM\ntpm <- assay(se_atlas_gene, \"gene_TPM\")\ntpm_matrices <- lapply(samples_per_tissue, function(x) {\n    \n    return(tpm[, x] |> as.data.frame() |> tibble::rownames_to_column(\"Gene\"))\n    \n})\n\n# Get expression data frames in counts\ncounts <- assay(se_atlas_gene, \"gene_counts\")\ncount_matrices <- lapply(samples_per_tissue, function(x) {\n    \n    return(counts[, x] |> as.data.frame() |> tibble::rownames_to_column(\"Gene\"))\n    \n})\n\n\n# Export data to .tsv files\noutdir <- here::here(\"app_data\", \"expression_by_body_part\")\nif(!dir.exists(outdir)) { dir.create(outdir, recursive = TRUE) }\n\ninvisible(lapply(seq_along(count_matrices), function(x) {\n    \n    tissue <- names(count_matrices)[x]\n    file <- file.path(outdir, paste0(tissue, \"_count.tsv\"))\n    \n    w <- readr::write_tsv(\n        count_matrices[[x]], \n        file = file\n    )\n    return(w)\n}))\n\ninvisible(lapply(seq_along(tpm_matrices), function(x) {\n    \n    tissue <- names(tpm_matrices)[x]\n    file <- file.path(outdir, paste0(tissue, \"_TPM.tsv\"))\n    \n    w <- readr::write_tsv(\n        tpm_matrices[[x]], \n        file = file\n    )\n    return(w)\n}))\n```\n:::\n\n\nNow, we will export transcript-level abundances.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(here(\"products\", \"result_files\", \"se_atlas_transcript.rda\"))\n\n# Get expression data frames in TPM\ntpm <- assay(se_atlas_transcript, \"tx_TPM\")\ntpm_matrices <- lapply(samples_per_tissue, function(x) {\n    \n    return(\n        tpm[, x] |> \n            as.data.frame() |> \n            tibble::rownames_to_column(\"Transcript\")\n    )\n    \n})\n\n# Get expression data frames in counts\ncounts <- assay(se_atlas_transcript, \"tx_counts\")\ncount_matrices <- lapply(samples_per_tissue, function(x) {\n    \n    return(\n        counts[, x] |> \n            as.data.frame() |> \n            tibble::rownames_to_column(\"Transcript\")\n    )\n    \n})\n\n\n# Export data to .tsv files\noutdir <- here::here(\"app_data\", \"expression_by_body_part\")\nif(!dir.exists(outdir)) { dir.create(outdir, recursive = TRUE) }\n\ninvisible(lapply(seq_along(count_matrices), function(x) {\n    \n    tissue <- names(count_matrices)[x]\n    file <- file.path(outdir, paste0(tissue, \"_count_tx.tsv\"))\n    \n    w <- readr::write_tsv(\n        count_matrices[[x]], \n        file = file\n    )\n    return(w)\n}))\n\ninvisible(lapply(seq_along(tpm_matrices), function(x) {\n    \n    tissue <- names(tpm_matrices)[x]\n    file <- file.path(outdir, paste0(tissue, \"_TPM_tx.tsv\"))\n    \n    w <- readr::write_tsv(\n        tpm_matrices[[x]], \n        file = file\n    )\n    return(w)\n}))\n```\n:::\n\n\n\n## R objects\n\nThe following R objects are small enough to be stored as .rda files, so that\nthey can be directly loaded when the app starts without compromising\nperformance. These `.rda` objects will be stored in the `data/` directory\nof the app.\n\n### project_metadata.rda\n\nThis object stores metadata at the BioProject level.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Create a project table to display in the \"Search by project\" tab\n#' \n#' @param metadata Data frame of sample metadata.\n#' \n#' @return A data frame with the variables:\n#' \\itemize{\n#'   \\item \n#'   \\item \n#' }\n#' @importFrom dplyr add_count select rename distinct group_by filter \n#' summarise arrange\n#' @importFrom stringr str_c\n#' @noRd\ncreate_project_table <- function(metadata = NULL) {\n    table <- metadata %>%\n        dplyr::filter(startsWith(BioProject, \"PRJ\")) %>%\n        dplyr::add_count(BioProject) %>%\n        dplyr::select(BioProject, n, Study_title, Study_abstract) %>%\n        dplyr::rename(\n            N = n, \n            `Study title` = Study_title,\n            `Study abstract` = Study_abstract\n        ) %>%\n        dplyr::distinct()\n    \n    tissue_count <- metadata %>%\n        dplyr::filter(startsWith(BioProject, \"PRJ\")) %>%\n        group_by(BioProject, Part) %>%\n        summarise(n = n()) %>%\n        ungroup() %>%\n        arrange(-n) %>%\n        group_by(BioProject) %>%\n        summarise(part_count = stringr::str_c(\n            Part, \": \", n, collapse = \" | \")\n        )\n    \n    final_table <- dplyr::inner_join(\n        table, tissue_count, by = \"BioProject\"\n    ) %>%\n        dplyr::rename(Part = part_count) %>%\n        dplyr::select(\n            BioProject, N, Part, `Study title`, `Study abstract`\n        )\n    return(final_table)\n}\n\n# Combine sample metadata into project metadata\nproject_metadata <- create_project_table(sample_metadata)\n\n# Create a data frame with PMID and DOI of publications associated with projects\nall_bioprojects <- unique(project_metadata$BioProject)\npub_info <- Reduce(rbind, lapply(all_bioprojects, function(x) {\n    message(x)\n    pubs <- read_html(\n        paste0(\"https://www.ncbi.nlm.nih.gov/bioproject/?term=\", x)\n    ) |>\n        html_nodes(\".RegularLink\") |>\n        html_attr(\"href\")\n    \n    # Get PMID\n    pmid <- pubs[grepl(\"/pubmed/\", pubs)]\n    pmid <- unique(gsub(\"/pubmed/\", \"\", pmid))\n    \n    id_table <- NULL\n    if(length(pmid) != 0) {\n        # Use PMID to extract DOI\n        doi <- sapply(pmid, function(y) {\n            d <- read_html(\n                paste0(\"https://pubmed.ncbi.nlm.nih.gov/\", y)\n            ) |>\n                html_nodes(\"a\") |>\n                html_attr(\"href\")\n            \n            d <- unique(d[grepl(\"doi\\\\.org/\", d)])[1]\n            return(d)\n        })\n        \n        id_table <- data.frame(\n            BioProject = x,\n            PMID = pmid,\n            DOI = doi\n        )\n    }\n    \n    return(id_table)\n}))\n   \npub_table <- pub_info |>\n    mutate(DOI = str_replace_all(DOI, \"https://doi.org/\", \"\")) |>\n    group_by(BioProject) |>\n    summarise(\n        DOI = paste0(DOI, collapse = \", \"),\n        PMID = paste0(PMID, collapse = \", \")\n    ) |>\n    mutate(\n        DOI = as.factor(DOI),\n        PMID = as.factor(PMID)\n    )\n    \npmeta <- left_join(project_metadata, pub_table) |>\n    dplyr::select(\n        BioProject, N, Part, `Study title`, `Study abstract`, DOI, PMID\n    )\n\nproject_metadata <- pmeta\n\n# Save object\nsave(\n    project_metadata, compress = \"xz\",\n    file = here(\"app_data\", \"project_metadata.rda\")\n)\n```\n:::\n\n\n\n### sample_metadata.rda\n\nThis file contains a data frame of sample metadata with the following fields:\n\n1. BioProject\n2. BioSample\n3. Part\n4. Treatment\n5. Cultivar\n6. Study_title\n7. Study_abstract\n8. DOI\n\nThis file was generated with the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nload(here(\"app_data\", \"project_metadata.rda\"))\n\n# Get a data frame of sample metadata\nsample_metadata <- as.data.frame(colData(se_atlas_gene)) |>\n    tibble::rownames_to_column(\"BioSample\") |>\n    dplyr::select(\n        BioProject, BioSample, Part, Treatment, Cultivar,\n        Study_title, Study_abstract\n    ) |>\n    inner_join(\n        project_metadata |>\n            dplyr::select(BioProject, DOI)\n    )\n\n# Save to file\nsave(\n    sample_metadata, compress = \"xz\",\n    file = here(\"app_data\", \"sample_metadata.rda\")\n)\n```\n:::\n\n\n### genes.rda\n\nThis object contains a character vector of all genes in the Soybean Expression\nAtlas. Not all genes in the genome are included here, as genes with no \ndetectable expression were not included in the expression matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenes <- rownames(se_atlas_gene)\n\nsave(\n    genes, compress = \"xz\",\n    file = here(\"app_data\", \"genes.rda\")\n)\n```\n:::\n\n\n### gene_descriptions.rda\n\nThis file contains a 2-column data frame with genes and their short\ndescriptions. Descriptions will be obtained from PLAZA Dicots 5.0.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame of all genes\ngenes_df <- data.frame(\n    Gene = sort(genes)\n)\n\n# Get descriptions from PLAZA Dicots 5.0\ngene_descriptions <- read_tsv(\n    file.path(\n        \"https://ftp.psb.ugent.be/pub/plaza/\",\n        \"plaza_public_dicots_05/Descriptions/gene_description.gma.csv.gz\"\n    ),\n    show_col_types = FALSE, skip = 8\n) |>\n    select(\n        Gene = `#gene_id`, Description = id\n    ) |>\n    mutate(Description = str_replace(Description, \".* - \", \"\")) |>\n    right_join(genes_df) |>\n    arrange(Gene)\n    \n# Save object\nsave(\n    gene_descriptions, compress = \"xz\",\n    file = here(\"app_data\", \"gene_descriptions.rda\")\n)\n```\n:::\n\n\n### tsne_coordinates.rda\n\nThis object contains t-SNE coordinates in a data frame\nwith the following variables:\n\n1. `tSNE1`: numeric, x-axis coordinates.\n2. `tSNE2`: numeric, y-axis coordinates.\n3. `BioSample`: factor, BioSample ID.\n4. `Part`: factor, plant part.\n5. `Treatment`: factor, treatment.\n6. `Cultivar`: factor, cultivar name.\n7. `DOI`: factor, publication DOI.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load tSNE plot\nload(here(\"products\", \"plots\", \"p_tsne_optimal_perplexity.rda\"))\nload(here(\"products\", \"result_files\", \"sample_metadata.rda\"))\n\n# Create data frame\ntsne_coordinates <- p_tsne_optimal_perplexity$data |>\n    tibble::rownames_to_column(\"BioSample\") |>\n    rename(\n        tSNE1 = X, \n        tSNE2 = Y,\n        Part = colour_by\n    ) |>\n    select(tSNE1, tSNE2, BioSample, Part) |>\n    mutate(\n        Part = str_to_title(Part),\n        Part = as.factor(Part),\n        BioSample = as.factor(BioSample)\n    ) |>\n    inner_join(\n        sample_metadata |>\n            select(BioSample, Treatment, Cultivar, DOI)\n    )\n\n# Save object\nsave(\n    tsne_coordinates, compress = \"xz\",\n    file = here(\"app_data\", \"tsne_coordinates.rda\")\n)\n```\n:::\n\n\n\n## Session information {.unnumbered}\n\nThis document was created under the following conditions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessioninfo::session_info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.0 (2023-04-21)\n os       Ubuntu 20.04.5 LTS\n system   x86_64, linux-gnu\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/Brussels\n date     2023-06-23\n pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n cli           3.6.1   2023-03-23 [1] CRAN (R 4.3.0)\n digest        0.6.31  2022-12-11 [1] CRAN (R 4.3.0)\n evaluate      0.20    2023-01-17 [1] CRAN (R 4.3.0)\n fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.3.0)\n htmltools     0.5.5   2023-03-23 [1] CRAN (R 4.3.0)\n htmlwidgets   1.6.2   2023-03-17 [1] CRAN (R 4.3.0)\n jsonlite      1.8.4   2022-12-06 [1] CRAN (R 4.3.0)\n knitr         1.42    2023-01-25 [1] CRAN (R 4.3.0)\n rlang         1.1.1   2023-04-28 [1] CRAN (R 4.3.0)\n rmarkdown     2.21    2023-03-26 [1] CRAN (R 4.3.0)\n rstudioapi    0.14    2022-08-22 [1] CRAN (R 4.3.0)\n sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n xfun          0.39    2023-04-20 [1] CRAN (R 4.3.0)\n yaml          2.3.7   2023-01-23 [1] CRAN (R 4.3.0)\n\n [1] /home/faalm/R/x86_64-pc-linux-gnu-library/4.3\n [2] /usr/local/lib/R/site-library\n [3] /usr/lib/R/site-library\n [4] /usr/lib/R/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}